<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: context/GameContext.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: context/GameContext.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { createContext, useContext, useState, useEffect } from 'react';

/**
 * React context that stores the full Planning Poker game state.
 * @type {React.Context}
 */
const GameContext = createContext();

/**
 * Hook to access the Planning Poker game context.
 *
 * @returns {Object} Game state and actions used across the application.
 * @throws {Error} If used outside of a {@link GameProvider}.
 */
export const useGame = () => {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
};

/**
 * Provider component that wraps the app and exposes game state and actions.
 *
 * @param {{ children: React.ReactNode }} props - React children that should have access to the game context.
 * @returns {JSX.Element} Provider wrapping the application.
 */
export const GameProvider = ({ children }) => {
  const [players, setPlayers] = useState([]);
  const [gameMode, setGameMode] = useState('strict'); // strict, average, median, absolute_majority, relative_majority
  const [backlog, setBacklog] = useState([]);
  const [currentFeatureIndex, setCurrentFeatureIndex] = useState(0);
  const [currentRound, setCurrentRound] = useState(1);
  const [votes, setVotes] = useState({});
  const [completedFeatures, setCompletedFeatures] = useState([]);
  const [gameStarted, setGameStarted] = useState(false);

  // Load saved game from localStorage on mount
  useEffect(() => {
    const savedGame = localStorage.getItem('planningPokerSave');
    if (savedGame) {
      // const data = JSON.parse(savedGame);
      // Restore game state if needed ??
    }
  }, []);

  /**
   * Download the current game state to a JSON file.
   *
   * The file can be reused later to restore the session.
   */
  const saveGameToFile = () => {
    const gameState = {
      players,
      gameMode,
      backlog,
      currentFeatureIndex,
      completedFeatures,
      timestamp: new Date().toISOString(),
    };
    
    const dataStr = JSON.stringify(gameState, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `planning-poker-save-${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
  };

  /**
   * Load a previously saved game state from a JSON file.
   *
   * @param {File} file - JSON file containing a previously exported game.
   * @returns {Promise&lt;void>} Resolves when the game state has been restored.
   */
  const loadGameFromFile = (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const gameState = JSON.parse(e.target.result);
          setPlayers(gameState.players || []);
          setGameMode(gameState.gameMode || 'strict');
          setBacklog(gameState.backlog || []);
          setCurrentFeatureIndex(gameState.currentFeatureIndex || 0);
          setCompletedFeatures(gameState.completedFeatures || []);
          setGameStarted(true);
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = reject;
      reader.readAsText(file);
    });
  };

  /**
   * Export only the results of the game (completed features + mode) as JSON.
   * The downloaded file is intended to be shared or archived.
   */
  const exportResults = () => {
    const results = {
      gameMode,
      completedFeatures: completedFeatures.map(f => ({
        name: f.name,
        description: f.description,
        estimatedDifficulty: f.estimatedDifficulty,
      })),
      timestamp: new Date().toISOString(),
    };
    
    const dataStr = JSON.stringify(results, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `planning-poker-results-${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
  };

  /**
   * Reset the whole game state to its initial values.
   */
  const resetGame = () => {
    setPlayers([]);
    setGameMode('strict');
    setBacklog([]);
    setCurrentFeatureIndex(0);
    setCurrentRound(1);
    setVotes({});
    setCompletedFeatures([]);
    setGameStarted(false);
  };

  /**
   * Register a vote for a given player.
   *
   * @param {string} playerId - Identifier of the player.
   * @param {string|number} value - Chosen card value.
   */
  const submitVote = (playerId, value) => {
    setVotes(prev => ({
      ...prev,
      [playerId]: value,
    }));
  };

  /**
   * Check if every player has already voted for the current round.
   *
   * @returns {boolean} True if all players have voted.
   */
  const checkIfAllVoted = () => {
    return players.every(player => votes[player.id] !== undefined);
  };

  /**
   * Check if all players picked the "coffee" card, meaning a break is needed.
   *
   * @returns {boolean} True if all votes are set to "coffee".
   */
  const checkCoffeeBreak = () => {
    return players.every(player => votes[player.id] === 'coffee');
  };

  /**
   * Compute the result of the current voting round based on the selected mode.
   *
   * @returns {{consensus: boolean, value: number|null}|null} Object describing consensus and chosen value.
   */
  const calculateResult = () => {
    const numericVotes = Object.values(votes)
      .filter(v => v !== 'coffee' &amp;&amp; v !== '?')
      .map(v => parseFloat(v));

    if (numericVotes.length === 0) return null;

    const allSame = numericVotes.every(v => v === numericVotes[0]);
    if (allSame || (gameMode === 'strict')) {
      if (allSame) {
        return { consensus: true, value: numericVotes[0] };
      }
      return { consensus: false, value: null };
    }

    if (currentRound > 1) {
      switch (gameMode) {
        case 'average': {
          const avg = numericVotes.reduce((a, b) => a + b, 0) / numericVotes.length;
          return { consensus: true, value: Math.round(avg * 10) / 10 };
        }
        case 'median': {
          const sorted = [...numericVotes].sort((a, b) => a - b);
          const mid = Math.floor(sorted.length / 2);
          const median = sorted.length % 2 === 0
            ? (sorted[mid - 1] + sorted[mid]) / 2
            : sorted[mid];
          return { consensus: true, value: median };
        }
        case 'absolute_majority': {
          const voteCounts = {};
          numericVotes.forEach(v => {
            voteCounts[v] = (voteCounts[v] || 0) + 1;
          });
          const maxCount = Math.max(...Object.values(voteCounts));
          if (maxCount > numericVotes.length / 2) {
            const majorityValue = Object.keys(voteCounts).find(k => voteCounts[k] === maxCount);
            return { consensus: true, value: parseFloat(majorityValue) };
          }
          return { consensus: false, value: null };
        }
        case 'relative_majority': {
          const voteCounts = {};
          numericVotes.forEach(v => {
            voteCounts[v] = (voteCounts[v] || 0) + 1;
          });
          const maxCount = Math.max(...Object.values(voteCounts));
          const majorityValue = Object.keys(voteCounts).find(k => voteCounts[k] === maxCount);
          return { consensus: true, value: parseFloat(majorityValue) };
        }
        default:
          return { consensus: false, value: null };
      }
    }

    return { consensus: false, value: null };
  };

  /**
   * Move to the next voting round, clearing previous votes.
   */
  const nextRound = () => {
    setVotes({});
    setCurrentRound(prev => prev + 1);
  };

  /**
   * Mark the current backlog feature as completed with a final estimate.
   *
   * @param {number} estimatedDifficulty - Final agreed difficulty for the feature.
   */
  const completeFeature = (estimatedDifficulty) => {
    const feature = backlog[currentFeatureIndex];
    setCompletedFeatures(prev => [
      ...prev,
      { ...feature, estimatedDifficulty },
    ]);
    setCurrentFeatureIndex(prev => prev + 1);
    setCurrentRound(1);
    setVotes({});
  };

  const value = {
    players,
    setPlayers,
    gameMode,
    setGameMode,
    backlog,
    setBacklog,
    currentFeatureIndex,
    currentRound,
    votes,
    completedFeatures,
    gameStarted,
    setGameStarted,
    submitVote,
    checkIfAllVoted,
    checkCoffeeBreak,
    calculateResult,
    nextRound,
    completeFeature,
    saveGameToFile,
    loadGameFromFile,
    exportResults,
    resetGame,
  };

  return &lt;GameContext.Provider value={value}>{children}&lt;/GameContext.Provider>;
};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#App">App</a></li><li><a href="global.html#Card">Card</a></li><li><a href="global.html#Game">Game</a></li><li><a href="global.html#GameContext">GameContext</a></li><li><a href="global.html#GameProvider">GameProvider</a></li><li><a href="global.html#Home">Home</a></li><li><a href="global.html#PlayerVoteStatus">PlayerVoteStatus</a></li><li><a href="global.html#Results">Results</a></li><li><a href="global.html#Setup">Setup</a></li><li><a href="global.html#useGame">useGame</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Dec 18 2025 12:40:45 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
